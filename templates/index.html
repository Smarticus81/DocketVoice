<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DocketVoice - Integrated Bankruptcy Platform</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 20px 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2rem;
            font-weight: 300;
        }
        
        .header p {
            margin: 8px 0 0 0;
            opacity: 0.9;
            font-size: 1rem;
        }
        
        .content {
            padding: 25px;
        }
        
        .tabs {
            display: flex;
            border-bottom: 2px solid #ecf0f1;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            background: #f8f9fa;
            border: none;
            font-size: 0.9rem;
            font-weight: 500;
            color: #7f8c8d;
            transition: all 0.3s ease;
            border-radius: 6px 6px 0 0;
            margin-right: 3px;
            margin-bottom: -2px;
        }
        
        .tab.active {
            background: #3498db;
            color: white;
            transform: translateY(-1px);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .control-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 3px solid #3498db;
        }
        
        .control-panel h3 {
            margin-top: 0;
            font-size: 1.1rem;
        }
        
        .status-panel {
            background: #e8f5e8;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 3px solid #27ae60;
        }
        
        .status-panel h4 {
            margin-top: 0;
            font-size: 1rem;
        }
        
        .error-panel {
            background: #fef2f2;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 3px solid #e74c3c;
            display: none;
        }
        
        .btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
            margin-right: 8px;
            margin-bottom: 8px;
        }
        
        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }
        
        .btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }
        
        .progress-bar {
            background: #ecf0f1;
            border-radius: 8px;
            height: 16px;
            margin: 12px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            height: 100%;
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 8px;
        }
        
        .case-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin-top: 15px;
        }
        
        .status-card {
            background: white;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #ecf0f1;
            text-align: center;
        }
        
        .status-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #3498db;
        }
        
        .status-label {
            color: #7f8c8d;
            font-size: 0.8rem;
            margin-top: 4px;
        }
        
        .log-output {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            max-height: 250px;
            overflow-y: auto;
            margin-top: 15px;
        }
        
        .upload-area {
            border: 2px dashed #bdc3c7;
            border-radius: 6px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            margin: 15px 0;
        }
        
        .upload-area:hover {
            border-color: #3498db;
            background: #f8f9fa;
        }
        
        .upload-area.dragover {
            border-color: #2980b9;
            background: #e8f4fd;
        }
        
        .hidden {
            display: none !important;
        }
        
        .microphone-status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #e74c3c;
            margin-left: 8px;
            animation: pulse 2s infinite;
        }
        
        .microphone-status.active {
            background: #27ae60;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .voice-controls {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            margin: 15px 0;
        }
        
        .voice-status {
            font-size: 1rem;
            margin-bottom: 12px;
            color: #2c3e50;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>DocketVoice Platform</h1>
            <p>Integrated Bankruptcy Consultation with WebRTC Voice Interface</p>
        </div>
        
        <div class="content">
            <!-- Tab Navigation -->
            <div class="tabs">
                <button class="tab active" onclick="switchTab(0)">Voice Consultation</button>
                <button class="tab" onclick="switchTab(1)">Case Management</button>
                <button class="tab" onclick="switchTab(2)">Document Processing</button>
                <button class="tab" onclick="switchTab(3)">System Status</button>
            </div>
            
            <!-- Tab 1: Voice Consultation -->
            <div class="tab-content active">
                <div class="control-panel">
                    <h3>Voice Consultation System</h3>
                    <div class="voice-controls">
                        <div class="voice-status" id="voiceStatus">Ready to start consultation</div>
                        <button class="btn" id="initVoiceBtn" onclick="initializeVoice()">
                            Initialize Voice System
                        </button>
                        <button class="btn btn-success" id="startVoiceBtn" onclick="startVoiceChat()" disabled>
                            Start Voice Consultation <span class="microphone-status" id="micStatus"></span>
                        </button>
                        <button class="btn btn-danger" id="stopVoiceBtn" onclick="stopVoiceChat()" disabled>
                            Stop Consultation
                        </button>
                    </div>
                </div>
                
                <div class="status-panel" id="consultationStatus" style="display: none;">
                    <h4>Consultation in Progress</h4>
                    <p>The AI is listening and ready to help with your bankruptcy consultation.</p>
                    <div class="progress-bar">
                        <div class="progress-fill" id="consultationProgress"></div>
                    </div>
                </div>
            </div>
            
            <!-- Tab 2: Case Management -->
            <div class="tab-content">
                <div class="control-panel">
                    <h3>Bankruptcy Case Management</h3>
                    <button class="btn" onclick="refreshCaseStatus()">Refresh Status</button>
                    <button class="btn btn-success" onclick="generateDocuments()">Generate Documents</button>
                    <button class="btn" onclick="performMeansTest()">Perform Means Test</button>
                </div>
                
                <div class="status-panel">
                    <h4>Current Case Status</h4>
                    <div class="case-status" id="caseStatusDisplay">
                        <div class="status-card">
                            <div class="status-value" id="completionPercent">0%</div>
                            <div class="status-label">Completion</div>
                        </div>
                        <div class="status-card">
                            <div class="status-value" id="formsCompleted">0</div>
                            <div class="status-label">Forms Completed</div>
                        </div>
                        <div class="status-card">
                            <div class="status-value" id="readyStatus">No</div>
                            <div class="status-label">Ready for Filing</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Tab 3: Document Processing -->
            <div class="tab-content">
                <div class="control-panel">
                    <h3>Document Upload & Processing</h3>
                    <div class="upload-area" onclick="document.getElementById('fileInput').click()">
                        <p>Click here or drag and drop documents</p>
                        <p style="color: #7f8c8d; font-size: 0.9rem;">Supported: PDF, JPG, PNG, TXT</p>
                        <input type="file" id="fileInput" style="display: none;" multiple 
                               accept=".pdf,.jpg,.jpeg,.png,.txt" onchange="handleFileUpload(this.files)">
                    </div>
                    
                    <div id="uploadProgress" class="progress-bar" style="display: none;">
                        <div class="progress-fill" id="uploadProgressFill"></div>
                    </div>
                </div>
                
                <div id="documentResults" class="status-panel" style="display: none;">
                    <h4>Processing Results</h4>
                    <div id="documentList"></div>
                </div>
            </div>
            
            <!-- Tab 4: System Status -->
            <div class="tab-content">
                <div class="control-panel">
                    <h3>System Health & Monitoring</h3>
                    <button class="btn" onclick="checkSystemHealth()">Check Health</button>
                    <button class="btn" onclick="clearLogs()">Clear Logs</button>
                </div>
                
                <div class="status-panel" id="healthStatus">
                    <h4>System Components</h4>
                    <div id="componentStatus">
                        <p>Click "Check Health" to verify system status</p>
                    </div>
                </div>
                
                <div class="log-output" id="systemLogs">
                    System ready. Click "Check Health" to initialize monitoring.
                </div>
            </div>
            
            <!-- Error Panel -->
            <div class="error-panel" id="errorPanel">
                <h4>Error</h4>
                <p id="errorMessage"></p>
                <button class="btn" onclick="hideError()">Dismiss</button>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let voiceInitialized = false;
        let consultationActive = false;
        let peerConnection = null;
        let dataChannel = null;
        let ephemeralToken = null;
        let realtimeModel = null;
        let sessionUpdated = false;
        
        // Tab switching
        function switchTab(index) {
            document.querySelectorAll('.tab').forEach((tab, i) => {
                tab.classList.toggle('active', i === index);
            });
            document.querySelectorAll('.tab-content').forEach((content, i) => {
                content.classList.toggle('active', i === index);
            });
        }
        
        // Error handling
        function showError(message) {
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('errorPanel').style.display = 'block';
            console.error('Error:', message);
        }
        
        function hideError() {
            document.getElementById('errorPanel').style.display = 'none';
        }
        
        // Voice system functions
        window.initializeVoice = async function() {
            try {
                updateVoiceStatus('Initializing voice system...');
                
                const response = await fetch('/api/initialize', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const result = await response.json();
                
                if (result.success) {
                    voiceInitialized = true;
                    document.getElementById('initVoiceBtn').disabled = true;
                    document.getElementById('startVoiceBtn').disabled = false;
                    updateVoiceStatus('Voice system ready - click Start to begin consultation');
                    logMessage('Voice system initialized successfully');
                } else {
                    throw new Error(result.error || 'Failed to initialize');
                }
            } catch (error) {
                showError(`Failed to initialize voice system: ${error.message}`);
                updateVoiceStatus('Failed to initialize - please try again');
            }
        }
        
        window.startVoiceChat = async function() {
            if (!voiceInitialized) {
                await initializeVoice();
                if (!voiceInitialized) return;
            }
            
            try {
                updateVoiceStatus('Setting up WebRTC connection...');
                
                // Get ephemeral token
                const tokenResponse = await fetch('/api/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const tokenResult = await tokenResponse.json();
                
                if (!tokenResult.success) {
                    throw new Error(tokenResult.error || 'Failed to get token');
                }
                
                ephemeralToken = tokenResult.ephemeral_token;
                realtimeModel = tokenResult.realtime_model;
                
                // Setup WebRTC
                await setupWebRTC();
                
                consultationActive = true;
                document.getElementById('startVoiceBtn').disabled = true;
                document.getElementById('stopVoiceBtn').disabled = false;
                document.getElementById('micStatus').classList.add('active');
                document.getElementById('consultationStatus').style.display = 'block';
                updateVoiceStatus('Consultation active - AI is listening');
                logMessage('Voice consultation started');
                
            } catch (error) {
                showError(`Failed to start voice chat: ${error.message}`);
                updateVoiceStatus('Failed to start - please try again');
            }
        }
        
        async function setupWebRTC() {
            const pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
            });
            
            // Get user media
            console.log('Requesting microphone access...');
            const ms = await navigator.mediaDevices.getUserMedia({
                audio: { 
                    echoCancellation: true,
                    noiseSuppression: true,
                    sampleRate: 24000
                }
            });
            console.log('Microphone access granted, tracks:', ms.getTracks().length);
            
            // Add audio track to peer connection
            const audioTrack = ms.getTracks()[0];
            console.log('Audio track:', audioTrack);
            pc.addTrack(audioTrack);
            
            // Handle incoming audio stream
            pc.ontrack = (event) => {
                console.log('Received remote audio track:', event.track);
                console.log('Track kind:', event.track.kind);
                console.log('Track enabled:', event.track.enabled);
                
                if (event.streams && event.streams[0]) {
                    console.log('Remote stream received with', event.streams[0].getTracks().length, 'tracks');
                    
                    // Create audio element for playback
                    const audioElement = new Audio();
                    audioElement.srcObject = event.streams[0];
                    audioElement.autoplay = true;
                    audioElement.volume = 1.0;
                    
                    // Add event listeners for debugging
                    audioElement.onloadedmetadata = () => {
                        console.log('Audio metadata loaded');
                        logMessage('Audio stream ready for playback');
                    };
                    
                    audioElement.onplay = () => {
                        console.log('Audio started playing');
                        logMessage('AI audio playback started');
                    };
                    
                    audioElement.onended = () => {
                        console.log('Audio playback ended');
                    };
                    
                    audioElement.onerror = (error) => {
                        console.error('Audio playback error:', error);
                        logMessage('Audio playback error occurred');
                    };
                    
                    // Store reference to clean up later
                    window.remoteAudio = audioElement;
                    
                    logMessage('Audio playback initialized');
                } else {
                    console.warn('No streams in track event');
                }
            };
            
            // Handle connection state changes
            pc.onconnectionstatechange = () => {
                console.log('WebRTC connection state:', pc.connectionState);
                logMessage(`WebRTC: ${pc.connectionState}`);
                
                if (pc.connectionState === 'connected') {
                    updateVoiceStatus('WebRTC connected - audio streaming active');
                    logMessage('🎉 WebRTC connection established successfully!');
                } else if (pc.connectionState === 'connecting') {
                    updateVoiceStatus('Connecting to OpenAI...');
                } else if (pc.connectionState === 'failed') {
                    showError('WebRTC connection failed');
                    updateVoiceStatus('Connection failed - check console for details');
                } else if (pc.connectionState === 'disconnected') {
                    updateVoiceStatus('WebRTC disconnected');
                }
            };
            
            // Handle ICE connection state changes
            pc.oniceconnectionstatechange = () => {
                console.log('ICE connection state:', pc.iceConnectionState);
                logMessage(`ICE: ${pc.iceConnectionState}`);
            };
            
            // Handle signaling state changes
            pc.onsignalingstatechange = () => {
                console.log('Signaling state:', pc.signalingState);
            };
            
            // Setup data channel for function calls
            const dc = pc.createDataChannel('oai-events', {
                ordered: true,
            });
            
            dc.onopen = () => {
                console.log('Data channel opened successfully');
                logMessage('Data channel connected - sending session configuration...');
                
                // Reset session update flag
                sessionUpdated = false;

                // Step 1: Send minimal session update first (instructions + basic settings)
                const minimalUpdate = {
                    type: "session.update",
                    session: {
                        instructions: `You are DocketVoice SOTA, an expert bankruptcy consultation AI assistant specializing in Chapter 7 and Chapter 13 bankruptcy cases. You are conducting a complete bankruptcy consultation to gather all necessary information for form completion.

CONSULTATION STRUCTURE:
1. INTRODUCTION & CHAPTER DETERMINATION
   - Greet the client professionally
   - Explain you'll be conducting a comprehensive bankruptcy consultation
   - Determine if they need Chapter 7 or Chapter 13 based on their situation
   - Explain the process will take 20-30 minutes

2. PERSONAL INFORMATION COLLECTION
   - Full legal name, SSN, date of birth
   - Current address and previous addresses (2 years)
   - Marital status and spouse information if applicable
   - Dependents and household size
   - Employment history and current income

3. FINANCIAL DATA COLLECTION
   - Monthly income from all sources
   - Monthly expenses (housing, utilities, food, transportation, etc.)
   - Assets (real estate, vehicles, bank accounts, investments, personal property)
   - Debts (credit cards, loans, mortgages, judgments, taxes)
   - Recent financial transactions and transfers

4. MEANS TEST ANALYSIS
   - Calculate median income for household size and state
   - Determine if Chapter 7 means test is passed
   - Analyze disposable income for Chapter 13 if needed

5. DOCUMENT GENERATION
   - Generate all required bankruptcy forms
   - Provide completion summary and next steps

COMMUNICATION STYLE:
- Professional but empathetic
- Clear explanations of bankruptcy concepts
- Ask follow-up questions for completeness
- Reassure clients about the process
- Use plain language, avoid excessive legal jargon

FUNCTION USAGE:
- Always call functions to process and store information
- Use collect_personal_info() for personal data
- Use collect_financial_data() for financial information
- Use perform_means_test_analysis() after gathering income/expense data
- Use generate_bankruptcy_documents() at the end

Begin by introducing yourself and explaining the consultation process.`,
                        modalities: ["audio", "text"],
                        voice: "alloy",
                        turn_detection: {
                            type: "server_vad",
                            threshold: 0.5,
                            prefix_padding_ms: 300,
                            silence_duration_ms: 500,
                            create_response: true,
                            interrupt_response: true
                        }
                        // Note: No temperature (let OpenAI use default) and no input_audio_transcription for minimal payload
                    }
                };

                dc.send(JSON.stringify(minimalUpdate));
                console.log('Minimal session update sent - waiting for confirmation...');
                logMessage('Step 1: Basic configuration sent');

                // Step 2: Send tools in a separate update after a short delay
                setTimeout(() => {
                    // Only send tools if session update was successful
                    if (!sessionUpdated) {
                        console.warn('Session update not confirmed yet, waiting...');
                        logMessage('Waiting for session update confirmation before sending tools...');
                        
                        // Retry after another delay
                        setTimeout(() => {
                            if (sessionUpdated) {
                                sendToolsUpdate(dc);
                            } else {
                                console.error('Session update failed - tools not sent');
                                logMessage('Session update failed - cannot proceed with tools');
                            }
                        }, 2000);
                        return;
                    }
                    
                    sendToolsUpdate(dc);
                }, 1000); // Wait 1 second for first update to be processed
            };
            
            dc.onerror = (error) => {
                console.error('Data channel error:', error);
                logMessage('Data channel error occurred');
            };
            
            dc.onmessage = (event) => {
                try {
                    console.log('Raw data channel message:', event.data);
                    const message = JSON.parse(event.data);
                    console.log('Parsed message:', message);
                    
                    // Handle schema validation errors and auto-retry
                    if (message.type === 'error') {
                        console.warn('Realtime error:', message.error);
                        logMessage(`OpenAI Error: ${message.error?.message || 'Unknown error'}`);
                        
                        // If we see a tools.type complaint, retry with corrected session update
                        if (String(message.error?.message || "").includes("session.tools") &&
                            String(message.error?.message || "").includes("type")) {
                            console.log('Retrying session update with corrected tool definitions...');
                            dc.send(JSON.stringify(sessionUpdate)); // Re-send the corrected object
                        }
                        return;
                    }
                    
                    if (message.type === 'function_call') {
                        handleFunctionCall(message.function_name, message.arguments);
                    } else if (message.type === 'response') {
                        logMessage('AI response received');
                    } else if (message.type === 'session.created') {
                        logMessage('OpenAI session created');
                    } else if (message.type === 'session.updated') {
                        sessionUpdated = true;
                        logMessage('OpenAI session updated successfully');
                        console.log('Session update confirmed - tools can now be sent');
                    } else if (message.type === 'conversation.item.created') {
                        logMessage('Conversation item created');
                    } else if (message.type === 'response.created') {
                        logMessage('AI response started');
                    } else if (message.type === 'response.audio.delta') {
                        // Audio data is being streamed
                        console.log('Receiving audio data...');
                    } else if (message.type === 'response.audio.done') {
                        logMessage('AI audio response complete');
                    } else {
                        console.log('Unknown message type:', message.type);
                        logMessage(`Received: ${message.type}`);
                    }
                } catch (error) {
                    console.error('Error parsing data channel message:', error);
                    console.error('Raw message:', event.data);
                }
            };
            
            // Create offer
            console.log('Creating WebRTC offer...');
            const offer = await pc.createOffer();
            console.log('Offer created:', offer.sdp.substring(0, 200) + '...');
            await pc.setLocalDescription(offer);
            console.log('Local description set');
            
            // Send to our Flask backend which handles OpenAI connection
            console.log('Sending offer to backend...');
            
            // Try sending SDP as raw text body first (preferred method)
            let sdpResponse;
            try {
                sdpResponse = await fetch('/api/webrtc-session', {
                    method: 'POST',
                    body: offer.sdp,  // Send raw SDP
                    headers: {
                        'Content-Type': 'application/sdp',
                        'X-Ephemeral-Token': ephemeralToken,
                        'X-Model': realtimeModel,  // Send model for exact matching
                    },
                });
            } catch (error) {
                console.log('Raw SDP method failed, trying JSON method...');
                // Fallback to JSON method
                sdpResponse = await fetch('/api/webrtc-session', {
                    method: 'POST',
                    body: JSON.stringify({
                        sdp: offer.sdp,
                        ephemeral_token: ephemeralToken,
                        model: realtimeModel  // Send model for exact matching
                    }),
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });
            }
            
            if (!sdpResponse.ok) {
                const errorText = await sdpResponse.text();
                console.error('Backend response not OK:', sdpResponse.status);
                console.error('Error details:', errorText);
                throw new Error(`WebRTC setup error: ${sdpResponse.status} - ${errorText}`);
            }
            
            const answerSdp = await sdpResponse.text();
            console.log('Received answer from backend:', answerSdp.substring(0, 200) + '...');
            
            await pc.setRemoteDescription({
                type: 'answer',
                sdp: answerSdp,
            });
            console.log('Remote description set');
            
            peerConnection = pc;
            dataChannel = dc;
            
            logMessage('WebRTC setup complete - waiting for connection...');
        }
        
        function sendToolsUpdate(dc) {
            const toolsUpdate = {
                type: "session.update",
                session: {
                    tools: [
                        {
                            type: "function",
                            name: "collect_personal_info",
                            description: "Collect and store personal information for bankruptcy forms",
                            parameters: {
                                type: "object",
                                properties: {
                                    full_name: { type: "string" },
                                    ssn: { type: "string" },
                                    date_of_birth: { type: "string" },
                                    address: { type: "string" },
                                    phone: { type: "string" },
                                    email: { type: "string" },
                                    marital_status: { type: "string" },
                                    spouse_info: {
                                        type: "object",
                                        properties: {
                                            full_name: { type: "string" },
                                            ssn: { type: "string" },
                                            date_of_birth: { type: "string" }
                                        },
                                        additionalProperties: true
                                    },
                                    dependents: {
                                        type: "array",
                                        items: {
                                            type: "object",
                                            properties: {
                                                name: { type: "string" },
                                                age: { type: "integer" },
                                                relationship: { type: "string" }
                                            },
                                            required: ["name"]
                                        }
                                    },
                                    employment: {
                                        type: "object",
                                        properties: {
                                            status: { type: "string" },
                                            employer: { type: "string" },
                                            position: { type: "string" },
                                            start_date: { type: "string" },
                                            income_frequency: { type: "string" }
                                        },
                                        additionalProperties: true
                                    }
                                },
                                required: ["full_name"],
                                additionalProperties: true
                            }
                        },
                        {
                            type: "function",
                            name: "collect_financial_data",
                            description: "Collect and store financial information",
                            parameters: {
                                type: "object",
                                properties: {
                                    monthly_income: { type: "number" },
                                    income_sources: {
                                        type: "array",
                                        items: { type: "string" }
                                    },
                                    monthly_expenses: {
                                        type: "object",
                                        additionalProperties: { type: "number" }
                                    },
                                    assets: {
                                        type: "array",
                                        items: {
                                            type: "object",
                                            properties: {
                                                type: { type: "string" },
                                                description: { type: "string" },
                                                value: { type: "number" }
                                            },
                                            required: ["type", "value"]
                                        }
                                    },
                                    debts: {
                                        type: "array",
                                        items: {
                                            type: "object",
                                            properties: {
                                                creditor: { type: "string" },
                                                account_number: { type: "string" },
                                                balance: { type: "number" },
                                                monthly_payment: { type: "number" },
                                                secured: { type: "boolean" }
                                            },
                                            required: ["creditor", "balance"]
                                        }
                                    },
                                    recent_payments: {
                                        type: "array",
                                        items: {
                                            type: "object",
                                            properties: {
                                                payee: { type: "string" },
                                                amount: { type: "number" },
                                                date: { type: "string" }
                                            },
                                            required: ["payee", "amount"]
                                        }
                                    }
                                },
                                required: ["monthly_income"],
                                additionalProperties: true
                            }
                        },
                        {
                            type: "function",
                            name: "perform_means_test_analysis",
                            description: "Perform means test calculation and chapter recommendation",
                            parameters: {
                                type: "object",
                                properties: {
                                    household_size: { type: "integer" },
                                    state: { type: "string" },
                                    total_monthly_income: { type: "number" }
                                },
                                required: ["household_size", "state", "total_monthly_income"]
                            }
                        },
                        {
                            type: "function",
                            name: "generate_bankruptcy_documents",
                            description: "Generate all required bankruptcy forms and documents",
                            parameters: {
                                type: "object",
                                properties: {
                                    chapter_type: { type: "string", enum: ["7", "13"] },
                                    include_schedules: { type: "boolean", default: true }
                                },
                                required: ["chapter_type"]
                            }
                        }
                    ],
                    tool_choice: "auto"
                }
            };

            dc.send(JSON.stringify(toolsUpdate));
            console.log('Tools update sent to OpenAI');
            logMessage('Step 2: Tools configured - AI ready for bankruptcy consultation');
        }
        
        async function handleFunctionCall(functionName, arguments) {
            try {
                logMessage(`Handling function call: ${functionName}`);
                
                const response = await fetch('/api/function-call', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        function_name: functionName,
                        arguments: arguments
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    logMessage(`Function call completed: ${functionName}`);
                    updateConsultationProgress();
                } else {
                    logMessage(`Function call failed: ${result.error}`);
                }
            } catch (error) {
                console.error('Error handling function call:', error);
                logMessage(`Function call error: ${error.message}`);
            }
        }
        
        window.stopVoiceChat = function() {
            consultationActive = false;
            
            // Stop and clean up remote audio
            if (window.remoteAudio) {
                window.remoteAudio.pause();
                window.remoteAudio.srcObject = null;
                window.remoteAudio = null;
            }
            
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            
            document.getElementById('startVoiceBtn').disabled = false;
            document.getElementById('stopVoiceBtn').disabled = true;
            document.getElementById('micStatus').classList.remove('active');
            document.getElementById('consultationStatus').style.display = 'none';
            updateVoiceStatus('Consultation stopped - click Start to resume');
            logMessage('Voice consultation stopped');
        }
        
        function updateVoiceStatus(status) {
            document.getElementById('voiceStatus').textContent = status;
        }
        
        function updateConsultationProgress() {
            const progress = Math.min(100, Math.random() * 30 + 10); // Simulated progress
            document.getElementById('consultationProgress').style.width = progress + '%';
        }
        
        // Case management functions
        async function refreshCaseStatus() {
            try {
                const response = await fetch('/api/case-status');
                const result = await response.json();
                
                if (result.success) {
                    const status = result.case_status;
                    document.getElementById('completionPercent').textContent = 
                        Math.round(status.completion_percentage) + '%';
                    document.getElementById('formsCompleted').textContent = 
                        `${status.forms_completed}/${status.total_forms}`;
                    document.getElementById('readyStatus').textContent = 
                        status.ready_for_filing ? 'Yes' : 'No';
                    logMessage('Case status refreshed');
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                showError(`Failed to refresh case status: ${error.message}`);
            }
        }
        
        async function generateDocuments() {
            try {
                logMessage('Generating bankruptcy documents...');
                
                const response = await fetch('/api/generate-documents', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const result = await response.json();
                
                if (result.success) {
                    logMessage(`Generated ${result.documents.length} documents successfully`);
                    await refreshCaseStatus();
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                showError(`Failed to generate documents: ${error.message}`);
            }
        }
        
        async function performMeansTest() {
            try {
                logMessage('Performing means test analysis...');
                
                const response = await fetch('/api/function-call', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        function_name: 'perform_means_test_analysis',
                        arguments: {}
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    logMessage('Means test analysis completed');
                    await refreshCaseStatus();
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                showError(`Failed to perform means test: ${error.message}`);
            }
        }
        
        // Document upload functions
        function handleFileUpload(files) {
            if (!files || files.length === 0) return;
            
            Array.from(files).forEach(file => uploadDocument(file));
        }
        
        async function uploadDocument(file) {
            try {
                const formData = new FormData();
                formData.append('file', file);
                
                document.getElementById('uploadProgress').style.display = 'block';
                document.getElementById('uploadProgressFill').style.width = '0%';
                
                // Simulate upload progress
                const progressInterval = setInterval(() => {
                    const current = parseFloat(document.getElementById('uploadProgressFill').style.width) || 0;
                    if (current < 90) {
                        document.getElementById('uploadProgressFill').style.width = (current + 10) + '%';
                    }
                }, 100);
                
                const response = await fetch('/api/upload-document', {
                    method: 'POST',
                    body: formData
                });
                
                clearInterval(progressInterval);
                document.getElementById('uploadProgressFill').style.width = '100%';
                
                const result = await response.json();
                
                if (result.success) {
                    logMessage(`Document ${file.name} processed successfully`);
                    displayDocumentResult(file.name, result);
                } else {
                    throw new Error(result.error);
                }
                
                setTimeout(() => {
                    document.getElementById('uploadProgress').style.display = 'none';
                }, 1000);
                
            } catch (error) {
                showError(`Failed to upload ${file.name}: ${error.message}`);
                document.getElementById('uploadProgress').style.display = 'none';
            }
        }
        
        function displayDocumentResult(filename, result) {
            const resultsDiv = document.getElementById('documentResults');
            const listDiv = document.getElementById('documentList');
            
            const resultItem = document.createElement('div');
            resultItem.style.cssText = 'margin: 10px 0; padding: 10px; background: #f0f8ff; border-radius: 5px;';
            resultItem.innerHTML = `
                <strong>${filename}</strong><br>
                Type: ${result.document_type || 'Unknown'}<br>
                Status: Processed successfully
            `;
            
            listDiv.appendChild(resultItem);
            resultsDiv.style.display = 'block';
        }
        
        // System monitoring functions
        async function checkSystemHealth() {
            try {
                const response = await fetch('/api/health');
                const result = await response.json();
                
                if (result.success) {
                    displayHealthStatus(result);
                    logMessage('System health check completed');
                } else {
                    throw new Error('Health check failed');
                }
            } catch (error) {
                showError(`Health check failed: ${error.message}`);
            }
        }
        
        function displayHealthStatus(health) {
            const statusDiv = document.getElementById('componentStatus');
            const components = health.components;
            
            let html = '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">';
            
            Object.entries(components).forEach(([name, status]) => {
                const statusColor = status ? '#27ae60' : '#e74c3c';
                const statusText = status ? 'Online' : 'Offline';
                
                html += `
                    <div style="padding: 10px; background: white; border-radius: 5px; border-left: 4px solid ${statusColor};">
                        <strong>${name.replace(/_/g, ' ').toUpperCase()}</strong><br>
                        <span style="color: ${statusColor};">${statusText}</span>
                    </div>
                `;
            });
            
            html += '</div>';
            html += `<p style="margin-top: 15px;"><strong>Version:</strong> ${health.version}</p>`;
            
            statusDiv.innerHTML = html;
        }
        
        function logMessage(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logDiv = document.getElementById('systemLogs');
            logDiv.innerHTML += `\n[${timestamp}] ${message}`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        function clearLogs() {
            document.getElementById('systemLogs').innerHTML = 'Logs cleared.';
        }
        
        // Initialize drag and drop
        document.addEventListener('DOMContentLoaded', function() {
            const uploadArea = document.querySelector('.upload-area');
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });
            
            ['dragenter', 'dragover'].forEach(eventName => {
                uploadArea.addEventListener(eventName, highlight, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, unhighlight, false);
            });
            
            uploadArea.addEventListener('drop', handleDrop, false);
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            function highlight(e) {
                uploadArea.classList.add('dragover');
            }
            
            function unhighlight(e) {
                uploadArea.classList.remove('dragover');
            }
            
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                handleFileUpload(files);
            }
            
            // Initial health check
            setTimeout(checkSystemHealth, 1000);
        });
    </script>
</body>
</html>
